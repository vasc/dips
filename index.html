<!doctype html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

	<!-- Basic Page Needs
  ================================================== -->
	<meta charset="utf-8" />
	<title>dips - distributed implementation of the peersim simulator</title>
	<meta name="description" content="">
	<meta name="author" content="">
	<!--[if lt IE 9]>
		<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	
	<!-- Mobile Specific Metas
  ================================================== -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /> 
	
	<!-- CSS
  ================================================== -->
	<link rel="stylesheet" href="stylesheets/base.css">
	<link rel="stylesheet" href="stylesheets/skeleton.css">
	<link rel="stylesheet" href="stylesheets/layout.css">	
	
	
<link rel="stylesheet" href="stylesheets/dips.css" type="text/css" media="screen" />
<link rel="stylesheet" href="stylesheets/pygments.css" type="text/css" media="screen" />
<link rel="stylesheet" href="stylesheets/nivo-slider.css" type="text/css" media="screen" />
<link rel="stylesheet" href="stylesheets/default.css" type="text/css" media="screen" />
<link href='http://fonts.googleapis.com/css?family=Cousine:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
<link href="http://fonts.googleapis.com/css?family=Cantarell:regular,italic,bold,bolditalic&amp;v1" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Droid+Sans:regular,bold&amp;v1" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans+Caption:regular,bold&amp;v1" rel="stylesheet" type="text/css">




	<!-- Favicons
	================================================== -->
	<link rel="shortcut icon" href="images/favicon.ico">
	<link rel="apple-touch-icon" href="images/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png" />
	<link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png" />
	
</head>
<body>





	<!-- Primary Page Layout
	================================================== -->
	
	<!-- Delete everything in this .container and get started on your own site! -->
	
  <header class="ribbon">
  </header>

	<div class="container">	
		
  <div class="three columns sidebar">
    <nav>
    <img class="logo" src="images/dips.png" alt="logo" />
      <h3 id="logo">Dips</h3>
      <ul>
        
          
          <li><a href="#Soft_Bounded_Divergence">Soft Bounded Divergence</a></li>
          
        
          
          <li class="min">pseudo-code: <a href="#MessageHandler">MessageHandler</a></li>
          
        
          
          <li><a href="#Strictly_Bounded_Divergence">Strictly Bounded Divergence</a></li>
          
        
          
          <li><a href="#Load_Balancing">Load Balancing</a></li>
          
        
          
          <li><a href="#Control">Control</a></li>
          
        
          
          <li class="min">pseudo-code: <a href="#MessageBundle">MessageBundle</a></li>
          
        
          
          <li><a href="#Cycle_based_Simulation">Cycle based Simulation</a></li>
          
        
      </ul>
    </nav>
    &nbsp;
  </div>

  <div class="twelve columns content offset-by-one">
    <header>
      <h1 class="remove-bottom">Distributed implementation of the Peersim Simulator</h1>
      <!--<hr />-->
    </header>

    
      <div id="Soft_Bounded_Divergence">
        
          <h2>Soft Bounded Divergence</h2>
          <p>Bounded divergence is a mechanism that allows simulation creator to define the maximum "latency" the simulation can tolerate.</p>
<p>Assinchronous message passing creates unrealistic clusters of simulated nodes that have much lower latency than outside messages. As locally generated messages are immediately delivered as opposed to outside messages that are bundled together to minimize the strain on the network. This bundling of messages may result in unrealistic latency that we wish to minimize.</p>
<p>Minimization is guaranteed by processing all outstanding messages whitin a gives time frame. All simulation instances maintain an event counter and and vector counter with one entry per simulation instance including the local one. The event counter must not be more than N events ( where N is defined in the simulation configuration ) ahead than any of the values in the vector counter. The event counter is updated every time an event is processed. Each vector counter is updated to the current event counter value when, either a message bundle is received from that instance or a request is made to that instance for new messages, which the simulator must do in order to proceed when the event counter reaches the N barrier. </p>
        
        
        
        <hr />
      </div>
    
      <div id="MessageHandler">
        
          
          <h2>MessageHandler <span class="tag">&nbsp;(pseudo-code)</span></h2>
          <table class="annotated">
            <tbody>
          
            
              <tr>
                <td class="comment"><p>Example code of a class to handle the message queue
implementing the <strong>bounded divergence</strong> algorithm.</p></td>
                <td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nx">MessageHandler</span>
   <span class="nv">constructor: </span><span class="nf">(bound_limit, dht) -&gt;</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>The limit of divergence allowed.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="k">this</span><span class="p">.</span><span class="nv">bound_limit = </span><span class="nx">bound_limit</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>The network abstraction.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="k">this</span><span class="p">.</span><span class="nv">dht = </span><span class="nx">dht</span>
      <span class="k">this</span><span class="p">.</span><span class="nv">message_queue = </span><span class="k">new</span> <span class="nx">Queue</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Global object containing the local simulation time. </p></td>
                <td class="code"><div class="highlight"><pre>      <span class="nv">current_time = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Set each instance clock to the current simulation time.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">dht</span><span class="p">.</span><span class="nx">instances</span>
         <span class="nv">instance.last_seen = </span><span class="nx">current_time</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Method to be called in order to add a message to the queue.</p></td>
                <td class="code"><div class="highlight"><pre>   <span class="nv">add_message: </span><span class="nf">(message) -&gt;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">message_queue</span><span class="p">.</span><span class="nx">enqueue</span> <span class="nx">message</span>
      <span class="nv">origin = </span><span class="k">this</span><span class="p">.</span><span class="nx">dht</span><span class="p">.</span><span class="nx">route</span> <span class="nx">message</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>The <em>last_seen</em> field is updated to the current time.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="nv">origin.last_seen = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Method to be called to get the next message.</p></td>
                <td class="code"><div class="highlight"><pre>   <span class="nv">retrieve_message: </span><span class="nf">() -&gt;</span>
      <span class="nv">current_time = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Filters the network list leaving only the ones that have not sent messages
for longer than the limit.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="nv">over_the_limit = </span><span class="nx">dht</span><span class="p">.</span><span class="nx">instances</span><span class="p">.</span><span class="nx">filter</span> <span class="nf">(instance) -&gt;</span>
         <span class="nv">difference = </span><span class="nx">current_time</span> <span class="o">-</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">last_seen</span>
         <span class="k">return</span> <span class="nx">difference</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">bound_limit</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Retreive any avilable messages from those instances.
This <strong>blocks the simulation</strong> until all responses have arrived.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">over_the_limit</span>
         <span class="nx">instance</span><span class="p">.</span><span class="nx">get_messages</span> <span class="nf">(message) -&gt;</span> 
            <span class="k">this</span><span class="p">.</span><span class="nx">add_message</span> <span class="nx">message</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Return the next message to process.</p></td>
                <td class="code"><div class="highlight"><pre>      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message_queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">()</span>
</pre></div>
</td>
              </tr>

          
            </tbody>
          </table>
          <div class="raw_code">
            <div class="highlight"><pre><span class="c1">#Example code of a class to handle the message queue</span>
<span class="c1">#implementing the **bounded divergence** algorithm.</span>
<span class="k">class</span> <span class="nx">MessageHandler</span>
   <span class="nv">constructor: </span><span class="nf">(bound_limit, dht) -&gt;</span>
      <span class="c1">#The limit of divergence allowed.</span>
      <span class="k">this</span><span class="p">.</span><span class="nv">bound_limit = </span><span class="nx">bound_limit</span>
      <span class="c1">#The network abstraction.</span>
      <span class="k">this</span><span class="p">.</span><span class="nv">dht = </span><span class="nx">dht</span>
      <span class="k">this</span><span class="p">.</span><span class="nv">message_queue = </span><span class="k">new</span> <span class="nx">Queue</span>

      <span class="c1">#Global object containing the local simulation time. </span>
      <span class="nv">current_time = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
      <span class="c1">#Set each instance clock to the current simulation time.</span>
      <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">dht</span><span class="p">.</span><span class="nx">instances</span>
         <span class="nv">instance.last_seen = </span><span class="nx">current_time</span>

   <span class="c1">#Method to be called in order to add a message to the queue.</span>
   <span class="nv">add_message: </span><span class="nf">(message) -&gt;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">message_queue</span><span class="p">.</span><span class="nx">enqueue</span> <span class="nx">message</span>
      <span class="nv">origin = </span><span class="k">this</span><span class="p">.</span><span class="nx">dht</span><span class="p">.</span><span class="nx">route</span> <span class="nx">message</span>

      <span class="c1">#The *last_seen* field is updated to the current time.</span>
      <span class="nv">origin.last_seen = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
   <span class="c1">#Method to be called to get the next message.</span>
   <span class="nv">retrieve_message: </span><span class="nf">() -&gt;</span>
      <span class="nv">current_time = </span><span class="nx">Globals</span><span class="p">.</span><span class="nx">time</span>
      
      <span class="c1">#Filters the network list leaving only the ones that have not sent messages</span>
      <span class="c1">#for longer than the limit.</span>
      <span class="nv">over_the_limit = </span><span class="nx">dht</span><span class="p">.</span><span class="nx">instances</span><span class="p">.</span><span class="nx">filter</span> <span class="nf">(instance) -&gt;</span>
         <span class="nv">difference = </span><span class="nx">current_time</span> <span class="o">-</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">last_seen</span>
         <span class="k">return</span> <span class="nx">difference</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">bound_limit</span>

      <span class="c1">#Retreive any avilable messages from those instances.</span>
      <span class="c1">#This **blocks the simulation** until all responses have arrived.</span>
      <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">over_the_limit</span>
         <span class="nx">instance</span><span class="p">.</span><span class="nx">get_messages</span> <span class="nf">(message) -&gt;</span> 
            <span class="k">this</span><span class="p">.</span><span class="nx">add_message</span> <span class="nx">message</span>

      <span class="c1">#Return the next message to process.</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">message_queue</span><span class="p">.</span><span class="nx">dequeue</span><span class="p">()</span>
</pre></div>

          </div>
        
        
        
        <hr />
      </div>
    
      <div id="Strictly_Bounded_Divergence">
        
          <h2>Strictly Bounded Divergence</h2>
          <p>The Soft Bounded Divergence Protocol is unable to completely prevent simulation instances to process events at a different rates. It guarantees that all messages generated during a interval of events for nodes localized in a specific instance are delivered within that interval. If any of the instances is either too slow or processing a larger number of events, it is possible that the messages for a given instance are created at a lower rate in this instance than in the others. As a result the messages generated at the slower instance will be consistently <em>older</em> that the ones generated elsewhere.</p>
<p>We introduce here a different protocol, instead of simply correcting the Divergence Protocol previously described, for three reasons. It is not necessarily true that a protocol requires all of the simulator instances to run at the same rate, divergence in event processing speed can be a important factor in p2p protocol testing. It is also worth noting that in order to guarantee similar event processing rates in every instance, the simulator instances must run at the speed of the slowest which is unacceptable in long simulations. Finally the DIPS simulation engine already makes an effort to guarantee load balancing between differently-able intances.</p>
<p>It may, however be necessary to guarantee a synchronization between all instances mainly for protocols that require communication between simulated nodes to always occur within a reasonably interval.</p>
<p>The Stricly Bounded Divergence Protocol creates event intervals delimited by the bounded divergence parameter, i.e. if the bounded divergence parameter is 1000 then interval 0 would be from event 0 to event 999, interval 1 from event 1000 to 1999, etc... To guarantee synchronization between instances an instance may not move to a different interval without contacting all other instances for new messages AND must wait until all messages generated locally in the last interval have been processed in the network, i.e. to move to interval 3, an instance must have confirmation that all messages it generated during interval 1 have been processed and all messages generated as a result have been delivered.</p>
<p>This will create a deadlock. To solve the deadlock, an instance will process all incoming messages it has procured within the current interval even if it must process more events than the ones defined by the bounded divergence parameter. However in order to guarantee fairness in the processing queue, messages generated by events processed in interval N after the bounded divergence limit will be tagged as N+1. </p>
        
        
        
        <hr />
      </div>
    
      <div id="Load_Balancing">
        
          <h2>Load Balancing</h2>
          <p>As we have seen, nodes in the network are assigned to simulation instances according to the hash value of their ID, using a CHORD like DHT.</p>
<p>This distribution may not fbe air when only a small number of simulation instances are in use. For instance, if only three simulation instances currently coexist in the network and their hash values happen to be very close in the DHT circle, it will result in an overburden simulation instances, while all other have very little work.</p>
<p>DIPS has an adaptive algorithm to correct this situation as well as any other situation where an instance is unable to cope with it's workload at the speed of the others. </p>
<p>We take advantage of the semantics in the IDs of the simulated nodes. Simulated nodes have a numeric ID identically distributed between 0 and N. The capacity of a simulation instance to handle it's assigned work, is defined as a value between 0 and 1, where 0 means it is unable to handle any work, and 1 means that it processes work either at the same rate or faster than any other instance.  In order to guarantee an effective load balancing the DIPS simulation protocol takes this value in to account when routing messages. Simulated node responsability varies during the simulation run time according to this value. </p>
<p>Instead of simply calculating the hash value of the node, and setting the responsibility to the simulation instance with the closest lower hash value, the protocol requires that a different DHT be created for each node. To create each node's particular DHT, we must filter out all instances that can not be responsible for this node. Only the instances that verify the following formula are considered in the DHT, guaranteeing that overloaded instances become responsible for less and less nodes until they reach an acceptable work rate. </p>
<p>NodeID &lt; NumberOfNodes * InstanceWorkCapacity</p>
        
        
        
        <hr />
      </div>
    
      <div id="Control">
        
          <h2>Control</h2>
          <p>A DIPS implementation requires communication between two or more instances of peersim. Peersim event simulator processes events as they arrive, however this poses several problems. As DIPS requires several instances to communicate, it becomes necessary to create a protocol to handle the communication. The protocol must be able to handle the initialization, control, failure and termination stages. </p>
<p>The relatively small number of instances involved in the process permits an approach where every instance knows of all others. This well know behavior guarantees simplicity allowing messages to be broadcasted to the entire network. The control protocol is a token based one, where only the token holder may send control messages to the network. Any instance may hold the token however, only one instance may hold it at any given time. An instance that initiates a simulation becomes responsible for it and may only relinquish the token when the simulation is over. </p>
<p>In order to acquire the token an instance must request it from it's current owner. If the owner is no longer responsible for a simulation and therefore may relinquish the token, it does so immediately after the first request, responding with the new owner's ID, to subsequent requests. If the current owner is forced to maintain the token in virtue of it's responsibility to the simulation it must maintain a queue of requests in the order of arrival. When the token is free to be passed along, the owner contacts each of the requesters in the queue order until one declares interest in the token or the queue ends. When the token is passed, the remaining requests in the queue are also passed and, take priority over new requests made to the new owner. </p>
<p>The only defined control messages are the INITIALIZE command, to start the execution of a new simulation and the TERMINATE command. The INITIALIZE command starts a new simulation and is accompanied by a description of the simulation as defined in peersim configuration files, with some simple additions.</p>
<h3>Termination</h3>
<p>Achiving a termination state is a non trivial task due to the distributed nature of the protocol. </p>
<p>Start with a simple termination protocol:</p>
<ul>
<li>Instances inform the coordinator of their willingness to terminate. </li>
<li>Coordinator sends termination command. </li>
</ul>
<p>Problem - Data may be lost in the wire. It is possible instance A to be empty, inform the coordinator, than instance B becomes empty and also informs the coordinator. The coordinator issues the terminate command, however in the mean time instance A has received data from instance B <strong>before</strong> it became empty. Aborting the procedure. </p>
<p>Intuitive solution - whenever an instance that was previously empty receives new data it also informs the coordinator.</p>
<p>Problem - the coordinator may still issue the terminate command before receiving updating the instance's status.</p>
<p>Solution - based on the three-phase commit protocol we add an extra step, before issuing the terminate command, the coordinator issues a prepare to terminate command, upon receiving this command, the instance must stop accepting messages, making sure all outstanding messages remain at the origin, and guaranteeing no message is lost in the wire. The coordinator must then wait for a positive acknowledge from all instances in order to terminate, if any instance replies negatively, implying that it has outstanding messages to either process or deliver, the the coordinator sends an abort command to al other instances and simulation continues normally. </p>
<h3>DHT</h3>
<p>The control protocol must also define how the simulated nodes are mapped to the instances running the simulation. This is necessary as messages passed between simulated nodes on different instances must be delivered efficiently. The network is defined as a distributed hash table where each instance position is given by the hash value of the instance's ip and port (as the "ip:port" string) the hash table is also extended as CHORD like circular structure. Simulated nodes are hashed according to their global identification number,  and the simulation instance responsible for any given node is defined (as in CHORD) as the instance with hash value immediately before the node own hash value. This method was chosen in order to facilitate future improvements in failure protocol, allowing the implementation of the CHORD protocol without change to the current behavior, even though a simple division of the nodes per number of simulation instances would be more efficient and would also guarantee an equalitarian distribution of the nodes independently of the number of simulation instances. </p>
        
        
        
        <hr />
      </div>
    
      <div id="MessageBundle">
        
          
          <h2>MessageBundle <span class="tag">&nbsp;(pseudo-code)</span></h2>
          <table class="annotated">
            <tbody>
          
            
              <tr>
                <td class="comment"><h5>Bundling of messages</h5>
<p>Pseudo-code on the implementation of the message bundling.</p></td>
                <td class="code"><div class="highlight"><pre><span class="k">class</span> <span class="nx">MessageBundle</span>
    <span class="nv">constructor: </span><span class="nf">(size) -&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nv">size = </span><span class="nx">size</span>
        <span class="k">this</span><span class="p">.</span><span class="nv">messages = </span><span class="k">new</span> <span class="nx">Buffer</span> <span class="nx">size</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Add message to the buffer, return true if the buffer is full.</p></td>
                <td class="code"><div class="highlight"><pre>    <span class="nv">add_message: </span><span class="nf">(message) -&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">append</span> <span class="nx">message</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span>

<span class="nf">(size) -&gt;</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Join the network.</p></td>
                <td class="code"><div class="highlight"><pre>    <span class="nv">dht = </span><span class="k">new</span> <span class="nx">DHT</span><span class="p">(</span><span class="nv">contact = </span><span class="s1">&#39;ip:port&#39;</span><span class="p">)</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Initiate message bundles in instance stubs.</p></td>
                <td class="code"><div class="highlight"><pre>    <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">dht</span>
        <span class="nv">instance.mb = </span><span class="k">new</span> <span class="nx">MessageBundle</span> <span class="nx">size</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Execute while there are messages outstanding.</p></td>
                <td class="code"><div class="highlight"><pre>    <span class="k">while</span> <span class="nv">message = </span><span class="nx">receive_message</span><span class="p">()</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>Find the message destination.</p></td>
                <td class="code"><div class="highlight"><pre>        <span class="nv">instance = </span><span class="nx">dht</span><span class="p">.</span><span class="nx">route</span> <span class="nx">message</span>
</pre></div>
</td>
              </tr>

          
            
              <tr>
                <td class="comment"><p>If bundle is full, send messages and create new buffer.</p></td>
                <td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">mb</span><span class="p">.</span><span class="nx">add_messsage</span> <span class="nx">message</span>
            <span class="nx">instance</span><span class="p">.</span><span class="nx">flush_mb</span><span class="p">()</span>
            <span class="nv">instance.mb = </span><span class="k">new</span> <span class="nx">MessageBundle</span> <span class="nx">size</span>
     
</pre></div>
</td>
              </tr>

          
            </tbody>
          </table>
          <div class="raw_code">
            <div class="highlight"><pre><span class="c1">###### Bundling of messages</span>
<span class="c1">#Pseudo-code on the implementation of the message bundling.</span>
<span class="k">class</span> <span class="nx">MessageBundle</span>
    <span class="nv">constructor: </span><span class="nf">(size) -&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nv">size = </span><span class="nx">size</span>
        <span class="k">this</span><span class="p">.</span><span class="nv">messages = </span><span class="k">new</span> <span class="nx">Buffer</span> <span class="nx">size</span>

    <span class="c1">#Add message to the buffer, return true if the buffer is full.</span>
    <span class="nv">add_message: </span><span class="nf">(message) -&gt;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">append</span> <span class="nx">message</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">messages</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span>

<span class="nf">(size) -&gt;</span>
    <span class="c1">#Join the network.</span>
    <span class="nv">dht = </span><span class="k">new</span> <span class="nx">DHT</span><span class="p">(</span><span class="nv">contact = </span><span class="s1">&#39;ip:port&#39;</span><span class="p">)</span>

    <span class="c1">#Initiate message bundles in instance stubs.</span>
    <span class="k">for</span> <span class="nx">instance</span> <span class="k">in</span> <span class="nx">dht</span>
        <span class="nv">instance.mb = </span><span class="k">new</span> <span class="nx">MessageBundle</span> <span class="nx">size</span>

    <span class="c1">#Execute while there are messages outstanding.</span>
    <span class="k">while</span> <span class="nv">message = </span><span class="nx">receive_message</span><span class="p">()</span>
        <span class="c1">#Find the message destination.</span>
        <span class="nv">instance = </span><span class="nx">dht</span><span class="p">.</span><span class="nx">route</span> <span class="nx">message</span>

        <span class="c1">#If bundle is full, send messages and create new buffer.</span>
        <span class="k">if</span> <span class="nx">instance</span><span class="p">.</span><span class="nx">mb</span><span class="p">.</span><span class="nx">add_messsage</span> <span class="nx">message</span>
            <span class="nx">instance</span><span class="p">.</span><span class="nx">flush_mb</span><span class="p">()</span>
            <span class="nv">instance.mb = </span><span class="k">new</span> <span class="nx">MessageBundle</span> <span class="nx">size</span>
     
</pre></div>

          </div>
        
        
        
        <hr />
      </div>
    
      <div id="Cycle_based_Simulation">
        
          <h2>Cycle based Simulation</h2>
          <p>Cycle based simulation is done through proxies. Linker protocols are required to request nodes from the Simulation class, which in turn will return proxies to the nodes simulated in other instances. Any call to these proxies will execute a network call to those nodes. A call to VOID methods will result in an asynchronous call, methods with a return type will result in a synchronous call, effectively stopping the simulation. Any proxy will be garbage collected after the execution of the currents node's call. </p>
        
        
        
        
      </div>
    

    <div class="slider-wrapper theme-default">
      <div class="slider">
        <img src="images/slides/terminate_1_naife.png" alt="" title="Naif protocol" />
        <img src="images/slides/terminate_2_naife.png" alt="" />
        <img src="images/slides/terminate_3_naife.png" alt="" />
        <img src="images/slides/terminate_4_naife.png" alt="" />
        <img src="images/slides/terminate_5_naife.png" alt="" />
      </div>
    </div>
  </div>


	</div><!-- container -->

		
		
		
		
	<!-- JS
	================================================== -->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.js"></script>
	<script>window.jQuery || document.write("<script src='javascripts/jquery-1.5.1.min.js'>\x3C/script>")</script>
	<script src="javascripts/app.js"></script>

	
  <script src="javascripts/jquery.nivo.slider.js" type="text/javascript"></script>


	
<!-- End Document
================================================== -->
</body>
</html>